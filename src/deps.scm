;;  This file is part of the arc package
;;  Copyright (C) 2002, 2003 by Gregor Klinke
;;
;;  This library is free software; you can redistribute it and/or modify it
;;  under the terms of the GNU Lesser General Public License as published
;;  by the Free Software Foundation; either version 2.1 of the License, or
;;  (at your option) any later version.
;;
;;  This library is distributed in the hope that it will be useful, but
;;  WITHOUT ANY WARRANTY; without even the implied warranty of
;;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
;;  Lesser General Public License for more details.
;;
;;  You should have received a copy of the GNU Lesser General Public
;;  License along with this library; if not, write to the Free Software
;;  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA

;; $Id: deps.scm,v 1.2 2003/04/17 00:04:24 eyestep Exp $


;; ----------------------------------------------------------------------
;; generic dependency support.
;;
;; most languages will use a (language) specific dependecy support, but
;; some functionality is supported by allmost all languages.
;;
;; this functions load and save (arc specific) dependency files, whereas
;; the language specific construction and setup of dependency files is
;; implementented in the appropriate task-*-deps.scm file
;;
;; the format of the dependency list: it returns a list with two elements,
;; the first is the target (in the makefile notation), and the second is an
;; list of cons'.  Each cons in the list have in its car the dependencie's
;; name and in the cdr the modification time
;;
;; example:
;; ("target.o" (("target.c" . 0) ("../include/types.h" . 0) 
;;    ("../include/gc.h" . 0)))
;; ----------------------------------------------------------------------

;; the directory where to put dependency files
(define %arc:deps-directory% ".arc/deps")

(arc:register-built-resource ".arc" 'recursive)

(define (arc:arc-tmp-directory)
  (let ((p (arc:path-append 
            (arc:string->path 
             (if (arc:context-script-home (arc:context-current))
                 (arc:context-script-home (arc:context-current))
                 ()))
            ".arc")))
    (if (arc:sys.file-exists? (arc:path->string p))
        p
        (begin
          (arc:sys.mkdirs (arc:path->string p))
          p))))

;; returns the dependency directory as a path object
(define (arc:deps-directory)
  (let ((p (arc:path-append 
            (arc:string->path 
             (if (arc:context-script-home (arc:context-current))
                 (arc:context-script-home (arc:context-current))
                 ()))
            %arc:deps-directory%)))
    (if (arc:sys.file-exists? (arc:path->string p))
        p
        (begin
          (arc:sys.mkdirs (arc:path->string p))
          p))))

;; creates a unified file name for a source name
(define (arc:deps-file-name fn)
  (let* ((fnp (arc:string->path fn))
         (fnbn (arc:path-replace-last-ext fnp "P")))
    (arc:path->string (arc:path-append 
                       (arc:deps-directory)
                       (arc:path-last-comp fnbn)))))

(define (arc:load-deps-file fn)
  (if (arc:sys.file-exists? fn)
      (let* ((port (open-input-file fn))
             (deps (read port)))
        (close-input-port port)
        deps)
      #f))

(define (arc:save-deps-file fn deps)
  (if (arc:sys.file-exists? fn)
      (delete-file fn))
  (let ((port (open-output-file fn)))
    ;; produce some informational stuff
    (display ";; don't edit this file" port) (newline port)
    (display ";; automatic created by arc vr " port) 
    (display %arc:version% port) (newline port)
    ;; write the real dependency thing
    (write deps port)
    (close-output-port port)))

;; walks on a dependency list as generated by parse-c-deps-file and fills
;; in the modification times in the deps cons'
(define (arc:deps-determine-mtime deps)
  (for-each (lambda (fc)
              (set-cdr! fc (arc:sys.get-mtime (car fc))) )
            (cadr deps))
  deps)

(define (arc:mtime-file-changed? deps ofile)
  (let ((mtime (arc:sys.get-mtime ofile))
        (dps (arc:deps-determine-mtime deps)))
    (let loop ((fc (cadr dps)))
      (if (null? fc)
          #f
          (or (< mtime (cdar fc))
              (loop (cdr fc))) ))))


;; loads the dependencies for a source file.  if no such sourcefile has
;; been created yet, build one using proc.  proc must except one parameter
;; (the source file name) and have to return a valid deps object or #f if
;; the dependencies couldn't computed
(define (arc:deps-get-deps sfile proc)
  (let* ((fn (arc:deps-file-name sfile))
         (df (arc:load-deps-file fn)))
    (if (not df)
        (let* ((deps (apply proc (list sfile))))
          (if deps
              (arc:save-deps-file fn deps))
          deps)
        df)))




;; checks if a given structure is likely to be a dependecy alist ... TODO:
;; how can we check if this is an deps alist?
(define (arc:deps-alist? deps)
  (and (arc:alist? deps)))




;; ----------------------------------------------------------------------
;; parsing dependency files as generated by makedeps
;; ----------------------------------------------------------------------
;; parses a dependency file as generate by a c compile and prepared for
;; Makefiles.  These files have the format:
;;
;; target.o: depc.c dep2.h dep3.h \
;;   dep4.h dep5.h dep6.h dep7.h \
;;   dep8.h
;;
;; it returns a list, its first element is the target (in the makefile
;; notation), and its second is an list of cons'.  Each cons in the list
;; have in its car the dependencie's name and in the cdr a zero (this is to
;; take the modification time later)
(define (arc:parse-make-deps-file fn)
  (let* ((port (open-input-file fn))
         (state 'pre-ws)
         (buf ())
         (target ())
         (deps ())
         )
    (do ((c (read-char port) (read-char port)))
        ((eof-object? c) #t)
      (case state
        ((pre-ws) (case c
                    ((#\space #\nl #\tab #\cr) 'ignore)
                    (else (begin
                            (set! state 'targ)
                            (set! buf (cons c buf))))))
        ((targ) (case c
                  ((#\:) (begin
                           (set! state 'targ-ws)
                           (set! target (list->string (reverse buf)))
                           (set! buf ())))
                  (else (set! buf (cons c buf)))))
        ((targ-ws) (case c
                     ((#\space #\nl #\tab #\cr) 'ignore)
                     (else (begin 
                             (set! state 'dep)
                             (set! buf (cons c buf))))))
        ((dep) (case c
                 ((#\space #\nl #\tab #\cr) 
                  (begin
                    (set! state 'ws)
                    (set! deps 
                          (append deps 
                                  (list (cons (list->string (reverse buf))
                                              0))))
                    (set! buf ())))
                 (else (set! buf (cons c buf)))))
        ((ws) (case c
                ((#\space #\nl #\tab #\cr) 'ignore)
                ((#\\) 'ignore)
                (else (begin
                        (set! state 'dep)
                        (set! buf (cons c buf))))))
        ))
    (close-input-port port)
    
    (list target deps) ))


;;Keep this comment at the end of the file 
;;Local variables:
;;mode: scheme
;;End:
